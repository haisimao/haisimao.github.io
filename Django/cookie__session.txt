request 对象是Django提供的集成了浏览器请求数据,服务器数据(session等)的一个对象.url请求发出时,url里面的数据是浏览器创建的

*******************************************************************
session的本质:
    虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。
    因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值中有该Session的id。Session依据该Cookie来识别是否为同一用户。在响应浏览器请求时(调用views中的函数时),即写入session时,需要对session的数据进行序列化,在得到浏览器请求时,需要用sessionid去唯一读取session里面的用户数据,并对它进行反序列化,

********************************************************************
通过request对象的session属性可以获取到session
session相当于是服务器端用来保存用户数据的一个字典
session利用了Cookie保存sessionid
通过sessionid就可以获取与某个用户对应的会话(也就是用户数据)
如果在浏览器中清除了Cookie那么也就清除了sessionid
再次访问服务器时服务器会重新分配新的sessionid这也就意味着之前的用户数据无法找回
默认情况下Django的session被设定为持久会话而非浏览器续存期会话
通过SESSION_EXPIRE_AT_BROWSER_CLOSE和SESSION_COOKIE_AGE参数可以修改默认设定
Django中的session是进行了持久化处理的因此需要设定session的序列化方式
1.6版开始Django默认的session序列化器是JsonSerializer
可以通过SESSION_SERIALIZER来设定其他的序列化器(例如PickleSerializer)

*****************************************************************
    后端与前端通过json数据格式交互数据；django 通过orm读取的数据，不能直接用django的serializable或python的序列化方式.

关于序列化的JSON方式:
    python的数据类型转换为JSON的数据格式,python的对象转换没有对应的JSON的数据类型,其他类型都有对应的数据类型.所以一般的做法是,将python的对象转换为dict,再进行JSON方式序列化,对应序列化的类型是object,python的所有属性以键值对的方式序列化为JSON格式,在JSON格式中dict就是对象.

    在JSON中键/值对的键（key)类型为 str, 当一个字典对象转换为JSON时，字典中的所有键的类型会被强制转换为strings，因此，当将字典转换为JSON再转换会字典时，当前字典可能与原字典不相等
























