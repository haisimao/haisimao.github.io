加载静态资源,资源放在static路径下

安装pymysql,Django默认安装的是musqldb,所以安装了朋友MySQL后需要再项目(虚拟环境里面的那个项目)的__innit__.py -->pymysql.install_as_MySQLdb()

模型&建表: 在python中建好模型(应用中的models),Django会自动建表,在models里面建立的类对应数据库的表,一个类的属性对应一个表的row,一个类的实例对应一个
表的行..
建好了models之后需要进行数据库的迁移,建表才会生效: 
    1. python manage.py makemigrations syst(应用名) --生成迁移,建立了两个文件001_initial.py与0002_auto_...py    
    2. python manage.py migrate   --迁移
每一次对表进行删除,修改,增加都要进行上面的步骤-->生成迁移-->迁移

对一个Django项目的主要操作是:
    1.做url的映射
    2.生成models,建立表
    3.views 编写映射的具体操作,查询models,表.返回html

models: 
        增删改
        dept = Dept.objects.get(pk=20) 查找一个类的对象(一个表的一行)
        dept.delete()           -- 删除一行
	dept.name = '研发1部'   -- 修改更新列
	dept.save()             -- 提交修改
	dept = Dept(no='10',name='财务部',location='成都') --增加
	dept.save()           -- 提交修改
      ************************
        查询 -- 查询的切片=分页查询
	Dept.objects.filter(name='财务部')  -- 严格查询
	Dept.objects.filter(name__contains='财务部').order_by('name')  -- 模糊查询
	Dept.objects.filter(name__icontains='财务部')  -- 模糊查询忽略大小写
	Dept.objects.filter(no__gt=30)  -- 范围查询,查询no > 的对象
        Dept.objects.filter(no__lte=60)  -- 范围查询,查询no <= 的对象
	emps_list = Dept.objects.get(no=no).emp_set.all()    # 关联表反查询:拿到关联表当中的具体一个对象内容,通过该对象反查目标查询表中的其他内容	
	emps_list[0].dept.name   --这也是关联查询+limit 1
	Emp.objects.filter(dept__no=no).select_related('dept')  # 关联查询



request 是浏览器给的请求的url的对象
request.META(请求头的数据的字典)
request.GET(url里的参数的字典)

all() / filter() / --> QuerySet
QuerySet使用了惰性查询,如果不是非得去到数据那么它不会发出SQL语句.
这样做是为了节省服务器内存的开销 - 延迟加载

{% url 'dept' %} 代替 'syst/dept/'
*********************************************************************
re_path(' ',),可以用正则表达式
url('emp/(?P<no>[0-9]+)',views.emps,name='emp')   Django1.*的版本
Django 2.* 的版本,正则表达式允许嵌套参数，Django将解析它们并将它们传递给视图。当反转时，Django将尝试填充所有外部捕获的参数，而忽略任何嵌套的捕获参数
    path('emp/<int:no>',views.emps,name='emp'),

*******************************************************************
序列化/串行化: 把类的对象按照某种方式处理成字节或者字符的序列
反序列化/反串行化: 把字符或者字节的序列重新还原成对象
实现序列化的工具 JSON / pickle(二进制) / shelve / jsonpickle
Django 中的序列化工具serialize,dumps()
from django.core.serilizers import serilize
serilize('json',object)
例:
第一个参数是要转换成JSON格式(序列化)的对象
encode参数要指定完成自定义对象序列化的编码器(JSONEncoder的子类型)
safe 参数的值如果为Ture那么传入的第一个参数只能是字典
  return JsonResponse(record_list,encoder=CarRecordEncoder,safe=False)

*********************************************************************
ORM  -  对象关系映射
对象模型 <---> 关系模型
实体类 <---> 二维表
属性 <---> 列
每一个对象 <---> 一条记录













